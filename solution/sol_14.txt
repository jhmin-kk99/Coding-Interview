컬렉션 프레임웍

컬렉션 프레임웍이란, '데이터 군을 저장하는 클래스들을 표준화한 설계'를 뜻한다.
컬렉션(Collection)은 다수의 데이터, 즉 데이터 그룹을, 프레임웍은 표준화된 프로그래밍 방식을 의미한다.

컬렉션 프레임웍은 컬렉션, 다수의 데이터,을 다루는 데 필요한 다양하고 풍부한 클래스들을 제공하기 때문
에 프로그래머의 짐을 상당히 덜어 주고 있으며, 또한 인터페이스와 다형성을 이용한 객체지향적 설계를
통해 표준화되어 있기 때문에 사용법을 익히기에도 편리하고 재사용성이 높은 코드를 작성할 수 있다는
장점이 있다.

컬렉션 프레임웍에서는 컬렉션데이터 그룹을 크게 3가지 타입이 존재한다고 인식하고 각 컬렉션을 다루는데
필요한 기능을 가진 3개의 인터페이스를 정의하였다. 그리고 인터페이스 List와 Set의 공통된 부분을 다시
뽑아서 새로운 인터페이스인 Collection을 추가로 정의하였다.
인터페이스 List와 Set을 구현한 컬렉션 클래스들은 서로 많은 공통부분이 있어서, 공통된 부분을 다시
뽑아 Collection인터페이스를 정의할 수 있었지만 Map인터페이스는 이들과는 전혀 다른 형태로 컬렉션을
다루기 때문에 같은 상속계층도에 포함되지 못했다.
이러한 설계는 객체지향언어의 장점을 극명히 보여주는 것으로 객체지향개념을 학습하는 사람들에게 많은 것
을 느끼게 한다. 후에 프로그래밍 실력을 어느 정도 갖추게 되었을 때 컬렉션 프레임웍의 실제 소스를 분석
해보면 객체지향적인 설계능력을 향상시키는데 많은 도움이 될 것이다.

List 순서가 있는 데이터의 집합. 데이터의 중복을 허용한다.
예) 대기자 명단 
구현 클래스 : ArrayList, LinkedList, Stack, Vector 등
Set 순서를 유지하지 않는 데이터의 집합. 데이터의 중복을 허용하지 않는다.
예) 양의 정수집합, 소수의 집합
구현 클래스 : HashSet, TreeSet 등
Map 키(key)와 값(Value)의 쌍(pair)으로 이루어진 데이터의 집합, 순서는 유지되지 않으며, 키는 중복을
허용하지 않고, 값은 중복을 허용한다.
예) 우편번호, 지역번호(전화번호) 
구현 클래스 : HashMap, TreeMap, HashTable, Properties 등

실제 개발 시에는 다루고자 하는 컬렉션의 특징을 파악하고 어떤 인터페이스를 구현한 컬렉션 클래스를 
사용해야하는지 결정해야하므로 각 인터페이스의 특징과 차이를 잘 이해하고 있어야 한다.
컬렉션 프레임웍의 모든 컬렉션 클래스들은 List, Set, Map 중의 하나를 구현하고 있으며, 구현한 인터
페이스의 이름이 클래스의 이름에 포함되어있어서 이름만으로 클래스의 특징을 쉽게 알 수 있도록 되어있다.
그러나, Vector, Stack, HashTable, Properties와 같은 클래스들은 프레임웍이 만들어지기 이전부터 존재
하던 것이기 때문에 컬렉션 프레임웍의 명명법을 따르지 않는다.
Vector나 HashTable과 같은 기존의 컬렉션 클래스들은 호환을 위해, 설계를 변경해서 남겨두었지만 가능
하면 사용하지 않는 것이 좋다. 그 대신 새로 추가된 ArrayList와 HashMap을 사용하자.

Collection인터페이스(List와 Set의 조상)는 컬렉션 클래스에 저장된 데이터를 읽고, 추가하고 삭제하는
등 컬렉션을 다루는데 가장 기본적인 메서드들을 정의하고 있다.

List인터페이스는 중복을 허용하면서 저장순서가 유지되는 컬렉션을 구현하는데 사용한다.
Set인터페이스는 중복을 허용하지 않고 저장순서가 유지되지 않는 컬렉션 클래스를 구현하는데 사용된다.
Map인터페이스는 키(key)와 값(value)을 하나의 쌍을 묶어서 저장하는 컬렉션 클래스를 구현하는 데 사용
된다. 키는 중복될 수 없지만 값은 중복을 허용한다.
기존에 저장된 데이터와 중복된 키와 값을 저장하면 기존의 값은 없어지고 마지막에 저장된 값이 남게 된다.

Map.Entry인터페이스는 Map인터페이스의 내부 인터페이스이다. 내부 클래스와 같이 인터페이스도 인터페이스
안에 인터페이스를 정의하는 내부 인터페이스를 정의하는 것이 가능하다.
Map에 저장되는 key-value쌍을 다루기 위해 내부적으로 Entry인터페이스를 정의해 놓았다. 이것은 보다
객체지향적으로 설계하도록 유도하기 위한 것으로 Map인터페이스를 구현하는 클래스에서는 Map.Entry인터
페이스도 함께 구현해야 한다.

ArrayList는 컬렉션 프레임웍에서 가장 많이 사용되는 컬렉션 클래스일 것이다. 
ArrayList는 기존의 Vector를 개선한 것으로 Vector와 구현원리와 기능적인 측면에서 동일하다.
ArrayList는 Object배열을 이용해서 데이터를 순차적으로 저장한다. 배열에 순서대로 저장되며, 배열에
더이상 저장할 공간이 없으면 보다 큰 새로운 배열을 생성해서 기존의 배열에 저장된 내용을 새로운 배열로
복사한 다음에 저장된다. 

for(int i= list2.size()-1; i>=0; i--){
  if(list1.contains(list2.get(i))){
    list2.remove(i);
  }
}
list2에서 list1과 공통되는 요소들을 찾아서 삭제하는 코드인데, list2.size()-1부터 감소시키면서 거꾸로
반복시켰다. 만일 변수 i를 증가시키면서 삭제하면, 한 요소가 삭제될 때마다 빈 공간을 채우기 위해 나머지
요소들이 자리이동을 하기 때문에 올바른 결과를 얻을 수 없다. 그래서 제어변수를 감소시켜가면서 삭제를
해야 자리이동이 발생해도 영향을 받지 않고 작업이 가능하다.
ArrayList를 생성할 때, 저장할 요소의 개수를 고려해서 실제 저정할 개수보다 약간 여유있는 크기로 하는 것
이 좋다. 생성할 때 지정한 크기보다 더 많은 객체를 저장하면 자동적으로 크기가 늘어나기는 하지만 이
과정에서 처리시간이 많이 소요되기 때문이다.

import java.util.*;

class VectorEx{
  public static void main(String[] args){
    Vector v = new Vector(5); //용량(capacity)이 5인 Vector를 생성한다.
    v.add("1");
    v.add("2");
    v.add("3");
    print(v);
    
    v.trimToSize(); //빈 공간을 없앤다. (용량과 크기가 같아진다.)
    System.out.println("After trimToSize()");
    print(v);
    
    v.ensureCapacity(6);
    System.out.println("After ensureCapacity(6)");
    print(v);
    
    v.setSize(7);
    System.out.println("After setSize(7)");
    print(v);
    
    v.clear();
    System.out.println("After clear()");
    print(v);
  }
  public static void print(Vector v){
    System.out.println(v);
    System.out.println("size :" + v.size());
    System.out.println("capacity :"+v.capacity());
  }
}
[1, 2, 3]
size :3
capacity :5
After trimToSize()
[1, 2, 3]
size :3
capacity :3
After ensureCapacity(6)
[1, 2, 3]
size :3
capacity :6
After setSize(7)
[1, 2, 3, null, null, null, null]
size :7
capacity :12
After clear()
[]
size :0
capacity :12

1. capacity가 5인 Vector인스턴스 v를 생성하고, 3개의 객체를 저장한 후의 상태
2. v.trimToSize()를 호출하면 v의 빈 공간을 없애서 size와 capacity를 같게 한다. 배열은 크기를 변경
할 수 없기 때문에 새로운 배열을 생성해서 그 주소값을 변수 v에 할당한다. 기존의 Vector인스턴스는 
더 이상 사용할 수 없으며, 후에 가비지컬렉터에 의해서 메모리에서 제거된다.
3. v.ensureCapacity(6)는 v의 capacity가 최소한 6이 되도록 한다. 만일 v의 capacity가 6이상이라면
아무 일도 일어나지 않는다. 현재는 v의 capacity가 3이므로 크기가 6인 배열을 생성해서 v의 내용을 복사
했다. 기존의 인스턴스를 다시 사용하는 것이 아니라 새로운 인스턴스를 생성하였다.
4. v.setSize(7)는 v의 size가 7이 되도록 한다. 만일 v의 capacity가 충분하면 새로 인스턴스를 생성하지
않아도 되지만 지금은 capacity가 6이므로 새로운 인스턴스를 생성해야 한다. Vector는 capacity가 부족할
경우 자동적으로 기존의 크기보다 2배의 크기로 증가된다. 그래서 v의 capacity는 12가 된다.
생성자 Vector(int initialCapacity, int capacityIncrement)를 사용해서 인스턴스를 생성한 경우에는 지정해준
capacityIncrement만큼 증가하게 된다.
5. v.clear();는 v의 모든 요소를 삭제한다. Vector는 Object배열이기 때문에 실제로는 주소가 저장되어야
한다.

ArrayList나 Vector 같이 배열을 이용한 자료구조는 데이터를 읽어오고 저장하는 데는 효율이 좋지만,
용량을 변경해야할 때는 새로운 배열을 생성한 후 기존의 배열로부터 새로 생성된 배열로 데이터를 복사해
야하기 때문에 상당히 효율이 떨어진다는 단점을 가지고 있다. 처음에 인스턴스를 생성할 때, 저장할 데이터의
개수를 잘 고려하여 충분한 용량의 인스턴스를 생성하는 것이 좋다.

List의 Object remove(int index)메서드는 지정된 위치(index)에 있는 객체를 삭제하고 삭제한 객체를
반환하도록 작성하였다. 1. 삭제할 객체의 바로 아래에 있는 데이터를 위로 복사해서 2. 삭제할 객체를 덮어쓰는
방식으로 처리한다. 만일 삭제할 객체가 마지막 데이터라면, 복사할 필요 없이 단순히 null로 변경해주기만
하면 된다. 3. 데이터가 삭제되어 데이터의 개수가 줄었으므로 size의 값을 1 감소시킨다.

