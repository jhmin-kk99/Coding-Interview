접근 제어자를 사용하는 이유

private : 같은 클래스 내에서만 접근이 가능
default : 같은 패키지 내에서만 접근이 가능
protected : 같은 패키지 내에서, 다른 패키지의 자손클래스에서 접근 가능
public : 접근 제한이 없음

클래스나 멤버, 주로 멤버에 접근 제어자를 사용하는 이유는 클래스의 내부에 선언된
데이터를 보호하기 위해서이다.
데이터가 유효한 값을 유지하도록, 또는 비밀번호와 같은 데이터를 외부에서 함부로 변경
하지 못하도록 하기 위해서는 외부로부터의 접근을 제한하는 것이 필요하다.
이것을 데이터 감추기(data hiding)라고 하며, 객체지향개념의 캡슐화(encapsulation)에
해당하는 내용이다.

또 다른 이유는 클래스 내에서만 사용되는, 내부 작업을 위해 임시로 사용되는 멤버변수나
부분작업을 처리하기 위한 메서드 등의 멤버들을 클래스 내부에 감추기 위해서이다.
외부에서 접근할 필요가 없는 멤버들을 private으로 지정하여 외부에 노출시키지 않음으로써
복잡성을 줄일 수 있다.

만일 메서드 하나를 변경해야 한다고 가정했을 때, 이 메서드의 접근 제어자가 public이라면,
메서드를 변경한 후에 오류가 없는지 테스트해야하는 범위가 넓다. 그러나 접근 제어자가
default라면 패키지 내부만 확인해 보면 되고, private이면 클래스 하나만 살펴보면 된다.
이처럼 접근 제어자 하나가 때로는 상당한 차이를 만들어낼 수 있다. 접근 제어자를 적절히
선택해서 접근 범위를 최소화하도록 노력하자.

get으로 시작하는 메서드(getter)는 단순히 멤버변수의 값을 반환하도록, set으로 시작하는 메서드
(setter)는 매개변수에 지정된 값을 검사하여 조건에 맞는 값일 때만 멤버변수의 값을 변경하도록 작성한다.
만일 상속을 통해 확장될 것이 예상되는 클래스라면 멤버에 접근 제한을 주되 자손클래스에서
접근하는 것이 가능하도록 하기 위해 private대신 protected를 사용한다. private이 붙은 멤버는
자손 클래스에서도 접근이 불가능하기 때문이다.

생성자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한할 수도 있다.
보통 생성자의 접근 제어자는 클래스의 접근 제어자와 같지만, 다르게 지정할 수도 있다.
생성자의 접근 제어자를 private으로 지정하면, 외부에서 생성자에 접근할 수 없으므로
인스턴스를 생성할 수 없게 된다. 그래도 클래스 내부에서는 인스턴스를 생성할 수 있다.
대신 인스턴스를 생성해서 반환해주는 public메서드를 제공함으로써 외부에서 이 클래스의 인스턴스
를 사용하도록 할 수 있다. 이 메서드는 public인 동시에 static이어야 한다.

class singleton{

	...
	private static Singleton s = new Singleton(); //getInstance()에서 사용될 수 있도록
	private Singleton(){							인스턴스가 미리 생성되어야 하므로
	...												static이어야 한다.
	}
	// 인스턴스를 생성하지 않고도 호출할 수 있어야 하므로 static이어야 한다.
	public static Singleton getInstance(){
		return s;
	}
	...
}

이처럼 생성자를 통해 직접 인스턴스를 생성하지 못하게 하고 public메서드를 통해 인스턴스에
접근하게 함으로써 사용할 수 있는 인스턴스의 개수를 제한할 수 있다.

생성자가 private인 클래스는 다른 클래스의 조상이 될 수 없다. 
자손클래스의 인스턴스를 생성할 때 조상클래스의 생성자를 호출해야만 하는데, 생성자의
접근제어자가 private이므로 자손클래스에서 호출하는 것이 불가능하기 때문이다.
그래서 클래스 앞에 final을 추가하여 상속할 수 없는 클래스라는 것을 알리는 것이 좋다.


