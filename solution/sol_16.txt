열거형(enums)이란? 애너테이션(annotation)이란?

열거형은 서로 관련된 상수를 편리하게 선언하기 위한 것으로 여러 상수를 정의할 때 사용하면 유용하다.

class Card{
  enum Kind {CLOVER, HEART, DIAMOND, SPADE}
  enum Value {TWO, THREE, FOUR}

  final Kind kind;
  final Value value;
}
자바의 열거형은 '타입에 안전한 열거형(typesafe enum)'이라서 실제 값이 같아도 타입이 다르면 컴파일
에러가 발생한다. 이처럼 값뿐만 아니라 타입까지 체크하기 때문에 타입에 안전하다고 하는 것이다.
더 중요한 것은 상수의 값이 바뀌면, 해당 상수를 참조하는 모든 소스를 다시 컴파일해야 한다는 것이다.
하지만 열거형 상수를 사용하면, 기존의 소스를 다시 컴파일하지 않아도 된다.

enum Direction {EAST, SOUTH, WEST, NORTH}
class Unit{
  int x,y;
  Direction dir;

  void init(){
    dir = Direction.EAST; //EAST로 초기화
  }
}
열거형 상수간의 비교에는 '=='를 사용할 수 있다. equals()가 아닌 '=='로 비교가 가능하다는 것은
그만큼 빠른 성능을 제공한다는 얘기다. 그러나 '<', '>'와 가은 비교연산자는 사용할 수 없고 compareTo()
는 사용가능하다. 
또한, switchㅁㄴ의 조건식에도 열거형을 사용할 수 있는데, 이 때 주의할 점은 case문에 열거형의 이름은
적지 않고 상수의 이름만 적어야 한다는 제약이 있다.

Direction[] dArr = Direction.values();
for(Direction d : dArr)
  System.out.printf("%s=%d%n", d.name(), d.ordinal());
values()는 열겨형의 모든 상수를 배열에 담아 반환한다. 이 메서드는 모든 열거형이 가지고 있는 것으로
컴파일러가 자동으로 추가해 준다. 그리고 ordinal()은 모든 열거형의 조상인 java.lang.Enum클래스에
정의된 것으로, 열거형 상수가 정의된 순서(0부터 시작)를 정수로 반환한다.

Enum클래스에 정의된 ordinal()이 열거형 상수가 정의된 순서를 반환하지만, 이 값을 열거형 상수의 값
으로 사용하지 않는 것이 좋다. 이 값은 내부적인 용도로만 사용되기 위한 것이기 때문이다.
열거형 상수의 값이 불연속적인 경우에는 열거형 상수의 이름 옆에 원하는 값을 괄호()와 함께 적어준다.

enum Direction{
  EAST(1), SOUTH(5), WEST(-1), NORTH(10); //끝에 ';'를 추가해야 한다.

  private final int value; //정수를 저장할 필드(인스턴스 변수)를 추가
  Direction(int value) {this.value = value;} //생성자를 추가 , private Direction(int value)와 동일
  public int getValue() {return value;}
}
열거형의 인스턴스 변수는 반드시 final이어야 한다는 제약은 없지만, value는 열거형 상수의 값을
저장하기 위한 것이므로 final을 붙였다. 그리고 외부에서 이 값을 얻을 수 있게 getValue()도 추가하였다.

필요하다면, 하나의 열거형 상수에 여러 값을 지정할 수도 있다. 

enum Direction{
  EAST(1,">"), SOUTH(2,"V"), WEST(3,"<"), NORTH(4,"^");
  private static final Direction[] DIR_ARR = Direction.values();
  private final int value;
  private final Stirng symbol;
  Direction(int value, String symbol){ //접근 제어자 private이 생략됨
    this.value = value;
    this.symbol = symbol;
  }
  public int getValue() {return value;}
  public String getSymbol() {return symbol;}

  public static Direction of(int dir){
    if(dir < 1 || dir > 4){
      throw new IllegalArgumentException("Invalid value :" + dir);
    }
    return DIR_ARR[dir - 1];
  }
}

class EnumEx{
  public static void main(String[] args){
    for(Direction d : Direction.values())
      System.out.printf("%s=%d%n", d.name(), d.getValue());
    Direction d1 = Direction.EAST;
    Direction d2 = Direction.of(1);
    ...
  }
}

열거형 Transportation은 운송 수단의 종류 별로 상수를 정의하고 있으며, 각 운송 수단에는 
기본요금(BASIC_FARE)이 책정되어 있다.
enum Transportation{
  BUS(100), TRAIN(150), SHIP(100), AIRPLANE(300);
  private final int BASIC_FARE;
  private Transportation(int basicFare){
    BASIC_FARE = basicFare;
  }
  int fare(){ //운송 요금을 반환
    return BASIC_FARE;
  }
}
거리에 따라 요금을 계산하는 방식이 각 운송 수단마다 다를 것이다. 이럴 때, 열거형에 추상 메서드
'fare(int distance)'를 선언하면 각 열거형 상수가 이 추상 메서드를 반드시 구현해야 한다.

enum Transportation{
  BUS(100){
    int fare(int distance){ return distance*BASIC_FARE;}
  }, TRAIN(150){
    int fare(int distance){ return distance*BASIC_FARE;}
  }, SHIP(100){
    int fare(int distance){ return distance*BASIC_FARE;}
  }, AIRPLANE(300){
    int fare(int distance){ return distance*BASIC_FARE;}
  };
  abstract int fare(int distance); //거리에 따른 요금을 계산하는 추상 메서드
  protected final int BASIC_FARE; //protected로 해야 각 상수에서 접근가능
  private Transportation(int basicFare){
    BASIC_FARE = basicFare;
  }
  public int getBasicFare(){     
    return BASIC_FARE;
  }
}

열거형 Direction이 다음과 같이 정의되어 있을 때,
enum Direction{ EAST, SOUTH, WEST, NORTH}
사실은 열거형 상수 하나하나가 Direction객체이다. 

class Direction{
  static final Direction EAST = new Direction("EAST");
  static final Direction SOUTH = new Direction("SOUTH");
  static final Direction WEST = new Direction("WEST");
  static final Direction NORTH = new Direction("NORTH");

  private String name;
  private Direction(String name){
    this.name = name;
  }
}
Direction클래스의 static상수 EAST, SOUTH, WEST, NORTH의 값은 객체의 주소이고, 이 값은 바뀌지
않는 값이므로 '=='로 비교가 가능한 것이다.
모든 열거형은 추상 클래스 Enum의 자손이므로, Enum을 흉내 내어 MyEnum을 작성하면 다음과 같다.

abstract class MyEnum<T extends MyEnum<T>> implements Comparable<T> {
  static int id = 0; //객체에 붙일 일련번호(0부터 시작)
  int ordinal;
  String name = "";
  public int ordinal() { return ordinal; }
  MyEnum(String name){
    this.name = name;
    ordinal = id++; //객체를 생성할 때마다 id의 값을 증가시킨다.
  }
  public int compareTo(T t){
    return ordinal - t.ordinal();
  }
}
만일 클래스를 MyEnum<T>와 같이 선언하였다면, compareTo()를 위와 같이 간단히 작성할 수 없었을 
것이다. 타입 T에 ordinal()이 정의되어 있는지 확인할 수 없기 때문이다.

abstract class MyEnum<T> implements Comparable<T>{
  ...
  public int compareTo(T t){
    return ordinal - t.ordinal(); //에러. 타입 T에 ordinal()이 있나?
  }
}
그래서 MyEnum<T extends<MyEnum<T>>와 같이 선언한 것이며, 이것은 타입 T가 MyEnum<T>의 자손이어야
한다는 의미이다. 타입 T가 MyEnum의 자손이므로 ordinal()이 정의되어 있는 것은 분명하므로 형변환
없이도 에러가 나지 않는다. 그리고 추상 메서드를 새로 추가하면, 클래스 앞에도 'abstract'를 붙여줘
야 하고, 각 static 상수들도 추상 메서드를 구현해주어야 한다. 

abstract class Direction extends MyEnum{
  static final Direction EAST = new Direction("EAST"){
  //익명 클래스
    Point move(Point p) {...}
  };
   static final Direction SOUTH = new Direction("SOUTH"){
  //익명 클래스
    Point move(Point p) {...}
  };
   static final Direction WEST = new Direction("WEST"){
  //익명 클래스
    Point move(Point p) {...}
  };
   static final Direction SOUTH = new Direction("SOUTH"){
  //익명 클래스
    Point move(Point p) {...}
  };
  private String name;
  private Direction(String name){
    this.name = name;
  }
  abstract Point move(Point p);
}


