java.lang 패키지와 자주 쓰이는 클래스들

java.lang 패키지
1. Object 클래스
2. String 클래스
3. StringBuffer, StringBuilder 

자주쓰이는 


1.
equals(Object obj)
매개변수로 객체의 참조변수를 받아서 비교하여 그 결과를 booean값으로 알려주는 역할을 한다.
  public boolean equals(Object obj){
    return (this==obj);
  }
서로 다른 두 객체를 equals메서드로 비교하면 항상 false를 결과로 얻게 된다.
equals메서드로 인스턴스가 가지고 있는 값을 비교하려면 오버라이딩을해서 주소가 아닌 객체에 저장된 내용을 비교하도록 변경하면 된다.

class Card{
  String kind;
  int number;
  
  Card(){
    this("SPADE" , 1);
  }
  Card(String kind, int number){
    this.kind = kind;
    this.number = number;
  }
  
  public boolean equals(Object obj){ //오버라이딩
    if(!(obj instanceof Card))
      return false;
    Card c = (card)obj;
    return this.kind.equals(c.kind) && this.number == c.number;
  }
}

hashCode()
이 메서드는 해싱(hashing)기법에 사용되는 '해시함수(hash function)'를 구현한 것이다.
해싱은 데이터관리기법 중의 하나인데 다량의 데이터를 저장하고 검색하는 데 유용하다.
해시함수는 찾고자하는 값을 입력하면, 그 값이 저장된 위치를 알려주는 해시코드(hash code)를 반환한다.
일반적으로 해시코드가 같은 두 객체가 존재하는 것이 가능하지만, Object클래스에 정의된 hashCode메서드는 객체의 주소값으로 해시코드를 만들어 int(4 byte)
반환하기 때문에 32bit JVM에서는 서로 다른 두 객체는 결코 같은 해시코드를 가질 수 없었지만, 64 bit JVM에서는 8 byte 주소값(long)으로 해시코드(4 byte)를
만들기 때문에 해시코드가 중복될 수 있다.
클래스의 인스턴스변수 값으로 객체의 같고 다름을 판단해야하는 경우라면 equals 메서드 뿐만 아니라 hashCode메서드도 적절히 오버라이딩해야 한다.
같은 객체라면 hashCode메서드를 호출했을 때의 결과값인 해시코드도 같아야 하기 때문이다.

class Card{
  String kind;
  int number;
  
  Card(){
    this("SPADE" , 1);
  }
  Card(String kind, int number){
    this.kind = kind;
    this.number = number;
  }
  
  public boolean equals(Object obj){ //오버라이딩
    if(!(obj instanceof Card))
      return false;
    Card c = (card)obj;
    return this.kind.equals(c.kind) && this.number == c.number;
  }
  
  public int hashCode(){ //오버라이딩
    return Objects.hash(kind,number); //매개변수가 가변인자라서 호출 시 지정하는 값의 개수가 정해져있지 않다.
  }
}
toString()
이 메서드는 인스턴스에 대한 정보를 문자열(String)로 제공할 목적으로 정의한 것이다.
인스턴스의 정보를 제공한다는 것은 대부분의 경우 인스턴스 변수에 저장된 값들을 문자열로 표현한다는 뜻이다.

public String toString(){
  return getClass().getName()+"@"+Integer.toHexString(hashCode());
}
클래스를 작성할 때 toString()을 오버라이딩하지 않는다면, 위와 같은 내용이 그대로 사용될 것이기 때문에 주로 아래와 같이 오버라이딩 한다.

public String toString(){
  return "kind : " + kind + ", number : " + number;
}

2.
기존의 다른 언어에서는 문자열을 char형의 배열로 다루었으나 자바에서는 문자열을 위한 클래스를 제공한다.(String 클래스)

한번 생성된 String인스턴스가 갖고 있는 문자열은 읽어 올 수만 있고, 변경할 수는 없다.

String a = "a";
String b = "b";
a = a + b;

'+'연산자를 이용해서 문자열을 결합하는 경우 인스턴스 내의 문자열이 바뀌는 것이 아니라 새로운 문자열 ("ab")이 담긴 String인스턴스가
생성된다. 이처럼 문자열을 결합하는 것은 매 연산 시 마다 새로운 문자열을 가진 String인스턴스가 생성되어 메모리공간을 차지하게 되므로
가능한 한 결합횟수를 줄이는 것이 좋다. 
문자열간의 결합이나 추출 등 문자열을 다루는 작업이 많이 필요한 경우에는 String클래스 대신 StringBuffer클래스를 사용하는 것이 좋다.
StringBuffer인스턴스에 저장된 문자열은 변경이 가능하므로 하나의 StringBuffer인스턴스만으로도 문자열을 다루는 것이 가능하다.

문자열을 만들 때는 문자열 리터럴을 지정한느 방법과 String클래스의 생성자를 사용해서 만드는 방법이 있다.
String클래스의 생성자를 이용한 경우에는 new연산자에 의해서 메모리할당이 이루어지기 때문에 항상 새로운 String인스턴스가 생성된다.
그러나 문자열 리터럴은 이미 존재하는 것을 재사용하는 것이다.(문자열 리터럴은 클래스가 메모리에 로드될 때 자동적으로 미리 생성된다.)
equals()를 사용하여 두 문자열을 비교한다.

자바 소스파일에 포함된 모든 문자열 리터럴은 컴파일 시에 클래스 파일에 저장된다. 이 때 같은 내용의 문자열 리터럴은 한번만 저장된다.
문자열 리터럴도 String인스턴스이고, 한번 생성하면 내용을 변경할 수 없으니, 하나의 인스턴스를 공유하면 되기 때문이다.

class StringEx{
  public static void main(String args[]){
    String s1 = "AAA";
    String s2 = "AAA";
    String s3 = "AAA";  
  }
}

"AAA"를 담고 있는 String인스턴스가 하나 생성된 후, 참조변수 s1,s2,s3는 모두 이 String인스턴스를 참조하게 된다.
클래스 파일에는 소스파일에 포함된 모든 리터럴의 목록이 있다. 해당 클래스 파일이 클래스 로더에 의해 메모리에 올라갈 때, 이 리터럴의 목록에 있는
리터럴들이 JVM내에 있는 '상수 저장소(constant pool)'에 저장된다. 이 때, 이곳에 "AAA"와 같은 문자열 리터럴이 자동적으로 생성되어 저장된다.

자바에서는 길이가 0인 배열이 존재할 수 있다. char형 배열도 길이가 0인 배열을 생성할 수 있고, 이 배열을 내부적으로 가지고 있는 문자열이
빈 문자열이다.

String s = "";

참조변수 s가 참조하고 있는 String인스턴스는 내부에 new char[0]과 같이 길이가 0인 char형 배열을 저장하고 있는 것이다.
일반적으로 변수를 선언할 때, 각 타입의 기본값으로 초기화 하지만, String과 char형은 다음과 같이 초기화한다.

String s = "";
char c = ' ';






















