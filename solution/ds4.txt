2-3, 2-3-4트리란?

# 2-3 Tree

2-3 트리(2-3 Tree)는 데이터를 저장하고 검색하기 위한 효율적인 자료구조로서, 
각 노드는 1개 또는 2개의 키(key)와 해당 키에 연결된 자식 노드들을 가지고 있다.

2-3 트리의 특징 :
- 각 내부 노드는 1개 또는 2개의 키를 가질 수 있다.
- 모든 리프 노드는 같은 레벨에 위치한다.
- 각 노드는 2개 또는 3개의 자식 노드를 가질 수 있다.
- 트리의 모든 리프 노드는 동일한 깊이에 있으며, 리프 노드의 수준은 트리의 높이가 된다.
- 트리의 모든 경로는 같은 길이를 가지고 있어서 트리가 균형 잡힌 상태를 유지한다.

2-3 트리는 데이터의 삽입과 삭제에 대한 재배치 작업이 필요하지만, 
이를 통해 트리의 균형을 유지하면서 효율적인 검색 성능을 제공한다. 트리의 균형을 유지하기 위해
노드 분할, 합병, 재구성 등의 작업이 수행되며, 이러한 작업은 트리의 높이를 최소화하여 검색 연산의
시간 복잡도를 낮추는데 기여한다.

Each Node has 1 or 2 keys
Thus, each Node has 2 or 3 children
** Not allowed to have a single child

All Leaves at the same level
- That is, Root to Leaf distance is the same for all leaves
Can you prove that the height of a 2-3 Tree is O(logN) when there are N keys?
- Hint : Maybe you don't try to calculate the height for fixed N, you could try to
find minimum and maximum of N for a fixed Height

# Proof of 2-3 Tree Height
The height of 2-3 Tree is H
then, 2^H <= # node <= 3^H
->
2^H <= # key (= N) <= 2*3^H
H = O(logN)

# 2-3 Tree Insert
Algorithm
1. (From Root) Go down the tree doing search until Leaf
2. (At Leaf) See if Leaf has 1 or 2 keys
- Case 1 key: Just insert in the Leaf
- Case 2 key: Split the node, Put 1 key in each node, save middle key for part3,
go to parent (middle key and 2 Pointers sent to Parent)
3. (Only if Case 2 Happened) Repeat the following if Case 2 happens
- Case 1 key in Parent : Put middle key and 2 Pointers in Parent
- Case 2 keys in Parent : Split the Parent and Put 1 key in each node, save middle key
for part 3, go to parent (middle key and 2 Pointers sent to Parent)
4. (If there is no Parent in Case 2) Make a new root, 1 key, 2 children

# 2-3-4 Tree











